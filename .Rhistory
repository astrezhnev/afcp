install.packages("esri2sf")
remotes::install_github("yonghah/esri2sf")
### Evictions analysis - distance and probability of default
### Hoffman and Strezhnev, 2022
### Packages
# Tidyverse
library(tidyverse)
library(ggplot2)
library(haven)
library(lubridate)
library(estimatr)
library(viridis)
# Geocoding/mapping
library(estimatr)
library(sf)
library(jsonlite)
library(esri2sf)
library(gridExtra)
library(xtable)
library(ggiraph)
library(ggiraphExtra)
library(rgdal)
library(ggpubr)
library(postmastr)
library(Xmisc)
### Packages
# Tidyverse
library(tidyverse)
library(ggplot2)
library(haven)
library(lubridate)
library(estimatr)
library(viridis)
# Geocoding/mapping
library(estimatr)
library(sf)
library(jsonlite)
library(esri2sf)
library(gridExtra)
library(xtable)
library(ggiraph)
library(ggiraphExtra)
library(rgdal)
library(ggpubr)
library(postmastr)
#library(Xmisc)
library(texreg)
library(hexbin)
# BinScatter
source("stat_binscatter.R")
##############################################################################
### Pre-processing!
##############################################################################
############################################
### Load in datasets
## Summary table
summary_table_full <- read_csv("phila-lt-data/summary-table.txt")
# Small weird isuse - drop duplicates
summary_table_full <- summary_table_full[!duplicated(summary_table_full$id),]
# Drop future cases
summary_table_full <- summary_table_full %>% filter(d_filing < ymd("2022-01-01"))
# Drop pre-2005
summary_table_full <- summary_table_full %>% filter(d_filing > ymd("2005-01-01"))
# Drop non-residential
summary_table_full <- summary_table_full %>% filter(non_residential == F)
#######
### Sample size summary - all original dockets
nrow(summary_table_full)
### Pew Data
pew_landlords <- read_dta("PewLandlords/PewLandlordsRentals2021.dta")
### Drop non-unique locations
pew_landlords <- pew_landlords %>% filter(!duplicated(LOCATION))
#################################
### Address cleaning here
#################################
## Clean up "Phila"
summary_table_full$clean_address <- gsub("PHILA.,", "PHILA,", summary_table_full$clean_address, fixed=T)
summary_table_full$clean_address <- gsub("Phila.,", "Phila,", summary_table_full$clean_address, fixed=T)
summary_table_full$clean_address <- gsub("phila.,", "phila,", summary_table_full$clean_address, fixed=T)
### postmastr metadata
philly_names <- c("PHILA", "philadelphia", "Phil", "phila", "Phila", "PHILADELPHIA", "Philadelphia", "PHILADELHPIA",
"PHILADEPHIA", "PHIADELPHIA", "Philadephia", "PHILADLEPHIA", "Philadlephia", "PHILADELPHA", "Philadephia", "PHLADELPHIA",
"Phialdelphia")
pa <- pm_dictionary(type = "state", filter = "PA", case = c("title", "upper"), locale = "us")
cities <- pm_append(type = "city", input = philly_names,
output = rep("Philadelphia", length(philly_names)))
dirs <- pm_dictionary(type = "directional", filter = c("N", "S", "E", "W"), locale = "us")
suf <- pm_dictionary(type="suffix")
## add Place to suf dictionary
suf2 <- data.frame(suf.type = c("Place", "Place", "Place"), suf.input = c("Place", "place", "PLACE"), suf.output = c("Pl", "Pl", "Pl"))
suf <- rbind(suf, suf2)
# Parse street names in pew_landlords data
pew_landlords <- pm_identify(pew_landlords, var = LOCATION)
test_landlord <- pm_prep(pew_landlords, var=LOCATION, type = "street")
# Fix fractionals
test_landlord$pm.address <- sub("1 at 2", "1/2", test_landlord$pm.address)
# Split and parse
pew_houses <- test_landlord %>% pm_house_parse()  %>% pm_houseFrac_parse() %>% pm_houseRange_parse(expand_range = T) %>% pm_streetDir_parse(dictionary = dirs) %>% pm_streetSuf_parse(dictionary = suf) %>% pm_street_parse()
# Number of number ranges found
pew_houses$pm.houseRange.count <- pew_houses$pm.houseRange %>% map_dbl(length)
# For each house in a range, expand out
pew_houses_full <- pew_houses %>% unite(., col="pm.building", pm.house, pm.houseFrac, pm.preDir, pm.street, pm.streetSuf, na.rm=T, sep = " ") %>% right_join(pew_houses %>% select(-pm.houseRange, -pm.houseRange.count), by="pm.uid")
# Merge in
pew_landlords <- pew_landlords %>% left_join(pew_houses_full, by="pm.uid")
# For each entry with houseRange > 1
pew_landlords_multihouse <- pew_landlords %>% filter(pm.houseRange.count > 1)
# Repeat each multihouse entry with pm.houseRange.count
pew_landlords_multi <- pew_landlords_multihouse[rep(row.names(pew_landlords_multihouse),
pew_landlords_multihouse$pm.houseRange.count),]
# Change building numbers
# For each multihouse - enter a single property
for (k in 1:nrow(pew_landlords_multihouse)){
pew_landlords_multi[pew_landlords_multi$pm.uid == pew_landlords_multihouse[k,]$pm.uid,]$pm.house <- pew_landlords_multihouse[k,]$pm.houseRange[[1]]
}
# Remake the pm.building
pew_landlords_multi$pm.building <- pew_landlords_multi  %>% select(pm.house, pm.houseFrac, pm.preDir, pm.street, pm.streetSuf)  %>% unite(., col="pm.building", pm.house, pm.houseFrac, pm.preDir, pm.street, pm.streetSuf, na.rm=T, sep = " ") %>% pull(pm.building)
# Tack it on to the main pew_landlords
pew_landlords <- bind_rows(pew_landlords, pew_landlords_multi)
# is pm.building unique - fix a few condos/sub-properties
pew_landlords <- pew_landlords %>% filter(!(pm.building == "514 South St"&LOCATION == "514-18 SOUTH STREET"))
pew_landlords <- pew_landlords %>% filter(!(pm.building == "230 Catharine St"&LOCATION == "228-30 CATHARINE STREET"))
pew_landlords <- pew_landlords %>% filter(!(pm.building == "24 S 22nd St"&LOCATION == "8L-24 SOUTH 22ND STREET"))
nrow(pew_landlords)
length(unique(pew_landlords$pm.building))
### pm.uid
summary_table_full <- pm_identify(summary_table_full, var = "clean_address")
test <- pm_prep(summary_table_full, "clean_address", type="street")
# Fix fractionals
test$pm.address <- sub("1 at 2", "1/2", test$pm.address)
# House merging
house_num <- test %>% pm_postal_parse() %>% pm_state_parse(dictionary = pa) %>% pm_city_parse(dictionary = cities) %>%
pm_house_parse() %>% pm_houseFrac_parse() %>% pm_streetDir_parse(dictionary = dirs) %>% pm_streetSuf_parse(dictionary = suf) %>% pm_street_parse()
# Combine into a single "building"
house_num_full <- house_num %>% unite(., col="pm.building", pm.house, pm.houseFrac, pm.preDir, pm.street, pm.streetSuf, na.rm=T, sep = " ") %>%
right_join(house_num %>% select(pm.uid, pm.house, pm.houseFrac, pm.preDir, pm.street, pm.streetSuf), by="pm.uid")
house_num_full <- house_num_full %>% select(pm.uid, pm.building)
# Merge to baseline
summary_table_full <- merge(summary_table_full, house_num_full, by="pm.uid", all.x=T, all.y=F)
# Try first merge to pew
summary_table_full <- summary_table_full %>% left_join(pew_landlords, by="pm.building")
# Remove extra pew landlords data
rm(pew_landlords_multi, pew_landlords_multihouse)
### Merge with opa data
OPA_data <- read_csv("phila-lt-data/opa_properties_public.csv")
OPA_data <- OPA_data %>% select(parcel_number, lat, lng)
pew_landlords <- pew_landlords %>% left_join(OPA_data, by=c("PARCEL_NUM" = "parcel_number"))
pew_landlords_geo <- pew_landlords %>% filter(!is.na(lat)&!is.na(lng))
#################
## Which addresses are valid
################
# Census tract
summary_table_full$TRACT11 <- as.character(sapply(summary_table_full$census, function(x) strsplit(x,"US")[[1]][2]))
# Valid Address
summary_table_full$bad_address <- as.integer(is.na(summary_table_full$pm.building)|is.na(summary_table_full$pm.house)|
is.na(summary_table_full$pm.street)|is.na(summary_table_full$pm.streetSuf))
summary_table_full <- summary_table_full %>% filter(bad_address == 0&!is.na(TRACT11))
nrow(summary_table_full)
length(unique(summary_table_full$pm.building))
## Clean memory
rm(house_num, house_num_full, pew_houses, pew_houses_full, test_landlord, test)
################################################
### Commuting time search
################################################
### Load in data - recents - Distance Matrix data
driving_distances <- read_csv("recent-phila-lt-data/unique-address-distances-driving.csv")
driving_distances2 <- read_csv("phila-lt-data/unique-address-distances-driving-new.csv")
driving_distances3 <- read_csv("phila-lt-data/unique-address-distances-driving-new2.csv")
driving_distances4 <- read_csv("recent-phila-lt-data/unique-address-distances-driving-remaining.csv")
driving_distances <- rbind(driving_distances, driving_distances2, driving_distances3, driving_distances4)
driving_distances <- driving_distances %>% rename(google_address_driving = google_address, search_status_driving=search_status)
driving_distances <- driving_distances[order(driving_distances$driving_duration, decreasing=T),]
transit_distances <- read_csv("phila-lt-data/unique-address-distances-transit-final.csv")
transit_distances <- transit_distances %>% rename(google_address_transit = google_address, search_status_transit=search_status)
transit_distances <- transit_distances[order(transit_distances$transit_duration, decreasing=T),]
transit_distances <- transit_distances[!duplicated(transit_distances$clean_address),]
driving_distances <- driving_distances[!duplicated(driving_distances$clean_address),]
#walking_distances <- read_csv("phila-lt-data/unique-address-distances-walking-final.csv")
#walking_distances <- walking_distances[!duplicated(walking_distances$clean_address),]
## Combine the two
combined_distances <- merge(transit_distances, driving_distances, by = "clean_address", all.x=T, all.y=F)
#combined_distances <- merge(combined_distances, walking_distances, by = "clean_address", all.x=T, all.y=F)
transit_distances_2 <- read_csv("phila-lt-data/unique-address-distances-transit-weekend.csv")
transit_distances_3 <- read_csv("phila-lt-data/unique-address-distances-transit-weekend-bonus.csv")
# Small validation
transit_match <- transit_distances_3 %>% left_join(transit_distances_2, by="clean_address") %>% filter(!is.na(google_address.y))
mean(transit_match$transit_duration.x - transit_match$transit_duration.y == 0)
transit_distances_2 <- rbind(transit_distances_2, transit_distances_3)
transit_distances_2 <- transit_distances_2 %>% rename(google_address_transit_weekend = google_address, search_status_transit_weekend=search_status, transit_duration_weekend = transit_duration, transit_distance_weekend = transit_distance)
transit_distances_2 <- transit_distances_2[order(transit_distances_2$transit_duration_weekend, decreasing=T),]
transit_distances_2 <- transit_distances_2[!duplicated(transit_distances_2$clean_address),]
combined_distances <- merge(combined_distances, transit_distances_2, by = "clean_address", all.x=T, all.y=F)
#sum(is.na(combined_distances$transit_duration_weekend))
combined_distances$weekend_gap <- combined_distances$transit_duration - combined_distances$transit_duration_weekend
#hist(combined_distances$weekend_gap)
## Merge with the summary table
summary_table_full <- merge(summary_table_full, combined_distances, by="clean_address", all.x=T, all.y=F)
summary_table_full %>% filter(is.na(transit_duration)) %>% filter(!duplicated(pm.building)) %>% select(clean_address)
summary_table_full %>% filter(is.na(transit_duration)) %>% summarize(n(), length(unique(pm.building)))
summary_table_full %>% filter(!is.na(transit_duration)&!is.na(transit_duration_weekend)) %>% summarize(n(), length(unique(pm.building)))
### Select out relevant fields from the summary table
sum(is.na(summary_table_full$driving_duration))
sum(is.na(summary_table_full$transit_duration))
sum(is.na(summary_table_full$transit_duration_weekend))
#summary_table_full %>%
### Drop the one where google can't find the address at all
summary_table_full <- summary_table_full %>% filter(!(google_address_driving == "Philadelphia, PA, USA"))
### Filing date
summary_table_full$d_filing <- ymd(summary_table_full$d_filing)
nrow(summary_table_full)
length(unique(summary_table_full$clean_address))
### Get the new geolocated addresses
new_geolocated <- read_csv("google maps/geolocate-updated.csv")
summary_table_full <- summary_table_full %>% left_join(new_geolocated, by="clean_address")
#summary_table_full %>% filter(!duplicated(clean_address)) %>% select(clean_address) %>% write_csv(file="google maps/geolocate_addresses_final.csv")
# Did the street address in google transit get the right number?
summary_table_full <- pm_identify(summary_table_full, var = "google_address_transit")
test2 <- pm_prep(summary_table_full, "google_address_transit", type="street")
# Fix fractionals
test2$pm.address <- sub("1 at 2", "1/2", test2$pm.address)
# House merging
house_num <- test2 %>% pm_postal_parse() %>% pm_state_parse(dictionary = pa) %>% pm_city_parse(dictionary = cities) %>%
pm_house_parse() %>% pm_houseFrac_parse() %>% pm_streetDir_parse(dictionary = dirs) %>% pm_streetSuf_parse(dictionary = suf) %>% pm_street_parse()
summary_table_full <- summary_table_full %>% left_join(house_num %>% select(pm.uid, pm.house2 = pm.house), by="pm.uid")
summary_table_full <- summary_table_full %>% filter(!is.na(pm.house2))
summary_table_full <- summary_table_full %>% filter(!is.na(transit_duration))
#####################
### Final sample size after pre-processing
nrow(summary_table_full)
length(unique(summary_table_full$pm.building))
## Clean memory
rm(transit_distances, transit_distances_2, transit_distances_3)
############################
## Geography stuff
###########################
### Make viridis greyscale
library(colorblindr) # devtools::install_github("clauswilke/colorblindr")
library(colorspace) # install.packages("colorspace", repos = "http://R-Forge.R-project.org") --- colorblindr requires the development version
# this also installs cowplot
library(cowplot)
#p3 <- ggplot(data=dFrame,aes(x=xVar,y=yVar)) +
#  geom_tile(aes(fill=z)) +
#  scale_fill_viridis_c()
#p3des<-edit_colors(p3, desaturate)
#ggdraw(p3des)
#get width given height
wd_hex <- function(height){
tri_side <- height/2
sma_side <- height/4
width <- 2*sqrt(tri_side^2 - sma_side^2)
return(width)
}
#now to figure out the area if you want
#side is simply height/2 in geom_hex
hex_area <- function(side){
area <- 6 * (  (sqrt(3)*side^2)/4 )
return(area)
}
#So if you want your hexagon to have a regular area need the inverse function
#Gives height and width if you want a specific area
hex_dim <- function(area){
num <- 4*area
den <- 6*sqrt(3)
vert <- 2*sqrt(num/den)
horz <- wd_hex(vert)
return(c(vert,horz))
}
## Truncated mean function - returns mean if vector length is above minBin otherwise NA
mean_trunc <- function(x, minBin=25){
if (length(x) >= minBin){
return(mean(x))
}else{
return(NA)
}
}
mapTheme <- function(base_size = 12) {
theme(
text = element_text( color = "black"),
plot.title = element_text(size = 14,colour = "black"),
plot.subtitle=element_text(face="italic"),
plot.caption=element_text(hjust=0),
axis.ticks = element_blank(),
panel.background = element_blank(),axis.title = element_blank(),
axis.text = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.minor = element_blank()
#panel.border = element_rect(colour = "black", fill=NA, size=2)
)
}
### Read in the philly map
phillyMap <- read_sf(dsn="Census Shapefile", layer="Census_Tracts_2010")
phillyMap$TRACT11 <- paste(phillyMap$STATEFP10, phillyMap$COUNTYFP10, phillyMap$TRACTCE10, sep="")
### Read in the philly block map
phillyBlockMap <- read_sf(dsn="Census Block", layer="Census_Block")
phillyBlockMap <- st_make_valid(phillyBlockMap)
phillyBlockMap$BLOCK_ID <- paste("1000000US", phillyBlockMap$GEOID10, sep="")
### Get point-in-shape google tracts
summary_table_geo <- st_as_sf(summary_table_full, coords=c("google_longitude", "google_latitude"), crs="WGS84")
summary_join <- st_join(summary_table_geo, phillyMap)
# Join on Blocks
summary_block_join <- st_join(summary_table_geo, phillyBlockMap)
# Fixed the Tracts!
summary_table_full$TRACT11 <- summary_join$TRACT11.y
summary_table_full$BLOCK_ID <- summary_block_join$BLOCK_ID
rm(summary_block_join, summary_table_geo, summary_join)
# Tract join
pew_landlords_geography <- st_as_sf(pew_landlords_geo, coords=c("lat", "lng"), crs="WGS84")
pew_landlords_join <- st_join(pew_landlords_geography, phillyMap)
pew_landlords_geo$TRACT11 <- pew_landlords_join$TRACT11
#########################
## Load in ACS Data
#########################
### Census Block race
census_race <- read_csv("ACS/Block/2010_block_race.csv")
census_race <- census_race %>% select(BLOCK_ID = GEO_ID, totalpopBlock = P001001, totalwhiteBlock = P001003, totalblackBlock = P001004)
summary_table_full <- merge(summary_table_full, census_race, by="BLOCK_ID", all.x=T)
summary_table_full$shareWhiteBlock = summary_table_full$totalwhiteBlock/summary_table_full$totalpopBlock
summary_table_full$shareBlackBlock = summary_table_full$totalblackBlock/summary_table_full$totalpopBlock
### Census Block Hispanic
census_hispanic <- read_csv("ACS/Block/2010_block_hispanic.csv")
census_hispanic <- census_hispanic %>% select(BLOCK_ID = GEO_ID, totalpopBlockHispanic = P002001, totalHispanicBlock = P002002)
summary_table_full <- merge(summary_table_full, census_hispanic, by="BLOCK_ID", all.x=T)
summary_table_full$shareHispanicBlock = summary_table_full$totalHispanicBlock/summary_table_full$totalpopBlockHispanic
### ACS Income
acs_income <- read_csv("ACS/acs_income.csv", na = c("", "NA", "-"))
## Grab median household income
acs_household_income <- acs_income %>% select(TRACT11=GEO.id2, medianIncome=HC01_EST_VC13)
### ACS Housing value
acs_housing <- read_csv("ACS/acs_housing.csv",na = c("", "NA", "-"))
## Grab median household income
acs_housing_info <- acs_housing %>% select(TRACT11=GEO.id2, medianGrossRent =HC01_VC191, numRenterOccupied = HC01_VC66)
### ACS
acs_contract <- read_csv("ACS/acs_contractRent.csv",na = c("", "NA", "-"))
## Grab median household income
acs_contract_info <- acs_contract%>% select(TRACT11=GEO.id2, medianContractRent =HD01_VD01)
### ACS Race
acs_race <- read_csv("ACS/acs_race.csv",na = c("", "NA", "-"))
## Grab median household income
acs_race_subset <- acs_race %>% select(TRACT11=GEO.id2, totalPopulation =HC01_VC48,  whitepct = HC03_VC54, blackpct = HC03_VC55, hispanicpct = HC03_VC93)
############################
## Merge ACS with individual-level leases
summary_table_full <- merge(summary_table_full, acs_household_income, by="TRACT11", all.x=T)
summary_table_full <- merge(summary_table_full, acs_race_subset, by="TRACT11", all.x=T)
summary_table_full <- merge(summary_table_full, acs_contract_info, by="TRACT11", all.x=T)
summary_table_full <- merge(summary_table_full, acs_housing_info, by="TRACT11", all.x=T)
summary_table_full <- summary_table_full %>% filter(!is.na(summary_table_full$medianIncome)&!is.na(summary_table_full$medianContractRent)&!is.na(summary_table_full$whitepct)&!is.na(summary_table_full$shareWhiteBlock))
###################
## Check in on sample sizes
nrow(summary_table_full)
length(unique(summary_table_full$pm.building))
length(unique(summary_table_full$LandlordG))
#########################################
## Landlord summary
########################################
########################################
## Case outcomes + names at the individual level
defendant_outcomes_full <- read_csv("phila-lt-data/docket_defendant_outcomes-updated-2005-newest-all-reopen2.csv")
# Fix defendant names
remove_all_occs <- function(x){
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND ALL ", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & ALL ", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND OCC", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & OCC", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," ALL OCC", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND OTHER OCC", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & OTHER OCC", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x,"AND ALL OTHER OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND ALLL OCCS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & ALLL OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & ALLOCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND ALLOTHER OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND ALLOCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND UNKNOWN OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," ALL OTHER OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND ALLL OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & A;LL OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND OTHER JOHN DOE OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND AALL OTHER OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AND AL OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & AL OCCUPANTS",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," & ALL",fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," D/B/A ",fixed=T)[[1]][1]))
return(x)
}
remove_aka <- function(x){
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," AKA ", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," CO-SIGNER", fixed=T)[[1]][1]))
x <- as.vector(sapply(x, FUN = function(x) strsplit(x," (CO-SIGNER)", fixed=T)[[1]][1]))
}
### Fix the names
defendant_outcomes_full$defendant <- toupper(defendant_outcomes_full$defendant)
defendant_outcomes_full$defendant <- gsub(" H/W", "", defendant_outcomes_full$defendant, fixed=T) ## Husband/Wife?
### Remove "And all Occupants"
defendant_outcomes_full$defendant <- remove_all_occs(defendant_outcomes_full$defendant)
### Remove AKAs
defendant_outcomes_full$defendant <- remove_aka(defendant_outcomes_full$defendant)
### Remove non-human entities
# PHA
defendant_outcomes_full <- defendant_outcomes_full[!grepl("PHILADELPHIA HOUSING AUTHORITY", defendant_outcomes_full$defendant, fixed=T),]
defendant_outcomes_full <- defendant_outcomes_full[!grepl("CITY OF PHILADELPHIA", defendant_outcomes_full$defendant, fixed=T),]
defendant_outcomes_full <- defendant_outcomes_full[!grepl("DEVELOPMENT CORPORATION", defendant_outcomes_full$defendant, fixed=T),]
# Incorporated
defendant_outcomes_full <- defendant_outcomes_full[!grepl("INC.", defendant_outcomes_full$defendant, fixed=T),]
# Incorporated
defendant_outcomes_full <- defendant_outcomes_full[!grepl(", INC", defendant_outcomes_full$defendant, fixed=T),]
# Incorporated
defendant_outcomes_full <- defendant_outcomes_full[!endsWith(defendant_outcomes_full$defendant," INC"),]
# Incorporated
defendant_outcomes_full <- defendant_outcomes_full[!grepl(", LLC", defendant_outcomes_full$defendant, fixed=T),]
defendant_outcomes_full <- defendant_outcomes_full[!grepl(", LTD", defendant_outcomes_full$defendant, fixed=T),]
# Incorporated
defendant_outcomes_full <- defendant_outcomes_full[!endsWith(defendant_outcomes_full$defendant, " LLC"),]
# of "PA"
defendant_outcomes_full <- defendant_outcomes_full[!endsWith(defendant_outcomes_full$defendant, " OF PA"),]
# Incorporated
defendant_outcomes_full <- defendant_outcomes_full[!grepl("ESTATE OF ", defendant_outcomes_full$defendant, fixed=T),]
defendant_outcomes_full <- defendant_outcomes_full[!grepl("TENANT UNION ", defendant_outcomes_full$defendant, fixed=T),]
defendant_outcomes_full <- defendant_outcomes_full[!defendant_outcomes_full$defendant == "ALL OCCUPANTS",]
defendant_outcomes_full <- defendant_outcomes_full[!defendant_outcomes_full$defendant == "OTHER OCCUPANTS",]
# Make sure there are some spaces
defendant_outcomes_full <- defendant_outcomes_full[grepl(" ", defendant_outcomes_full$defendant, fixed=T),]
# Drop duplicate IDs/defendants
defendant_outcomes_full <- defendant_outcomes_full %>% filter(!duplicated(defendant_outcomes_full %>% select(id, defendant)))
### Recode outcomes based on what happened
defendant_outcomes_full <- defendant_outcomes_full %>% mutate(outcomeCombined = case_when(
grepl("Dismissed", outcome, ignore.case=T) ~ "Dismissed",
grepl("Withdrawn", outcome, ignore.case=T) ~ "Withdrawn",
grepl("Settled", outcome, ignore.case=T) ~ "Settled",
grepl("by Agreement", outcome, ignore.case=T) ~ "Judgment by Agreement",
grepl("Mediation Agreement", outcome, ignore.case=T) ~ "Judgment by Agreement",
grepl("Judgment for Plaintiff by default",outcome, ignore.case=T) ~ "For Plaintiff by Default",
grepl("Judgment for Defendant by default",outcome, ignore.case=T) ~ "For Defendant by Default",
grepl("Judgment for Plaintiff",outcome, ignore.case=T) ~ "For Plaintiff",
grepl("Judgment for Defendant",outcome, ignore.case=T) ~ "For Defendant",
grepl("Judgment for Possession Only", outcome, ignore.case=T) ~ "For Defendant",
grepl("Judgment for Rent Only", outcome, ignore.case=T) ~ "For Defendant",
outcome == "Disposition - Action Withdrawn Judgment Stands" ~ "Other",
outcome == "Disposition - Adjudication Deferred" ~ "Other",
outcome == "Disposition - Deferred due to Bankruptcy filing" ~ "Other",
outcome == "Disposition - Held Under Advisement" ~ "Other",
outcome == "No Disposition" ~ "Other",
outcome == "Disposition - Unusual Event" ~ "Other",
outcome == "Disposition - Resolved by Arbitration Order" ~ "Other",
grepl("Resolved by Arbitration Order", outcome, ignore.case=T) ~ "Other",
outcome == "Disposition - Dismiss Additional Service Address" ~ "Other",
outcome == "Disposition - Case to be Consolidated" ~ "Other",
outcome == "Disposition - Case Amended, See Remarks:" ~ "Other",
outcome == "Disposition - Fine Not Paid" ~ "Other",
TRUE ~ "ERROR: MISSED ONE"))
### Merge to summary data
defendant_outcomes_merged <- defendant_outcomes_full %>% left_join(summary_table_full, by = "id")
### Fix rent
defendant_outcomes_merged$ongoing_rent[defendant_outcomes_merged$ongoing_rent ==11650.00] <- 1165
defendant_outcomes_merged$ongoing_rent[defendant_outcomes_merged$ongoing_rent ==9500.00] <- 950
## Drop if we don't have driving duration
defendant_outcomes_merged <- defendant_outcomes_merged %>% filter(!is.na(driving_duration))
defendant_outcomes_merged <- as.data.frame(defendant_outcomes_merged)
# Drop if we don't have the complaint
defendant_outcomes_merged <- defendant_outcomes_merged %>% filter(!is.na(complaint))
length(unique(defendant_outcomes_merged$id))
length(unique(defendant_outcomes_merged$pm.building))
length(unique(defendant_outcomes_merged$Landlord))
nrow(defendant_outcomes_merged)
rm(defendant_outcomes_full)
#############################################
#### Classified Name data - Race
#defendant_race <- read_csv("names_with_race_3.csv") %>% select(defendant, asian, hispanic = hispanic...8, nh_black, nh_white)
##### Classified Gender data
#defendant_gender <- read_csv("names_with_gender_3.csv")
### Collapse to unique names
#defendant_race <- defendant_race[!duplicated(defendant_race$defendant),]
#defendant_gender <- defendant_gender[!duplicated(defendant_gender$defendant),]
################################################################################
### Merge to gender and race data
#defendant_outcomes_merged <- defendant_outcomes_merged %>% left_join(defendant_gender, by="defendant")
#defendant_outcomes_merged <- defendant_outcomes_merged %>% left_join(defendant_race, by="defendant")
#defendant_outcomes_merged <- merge(defendant_outcomes_merged, summary_table_full, by="id", all.x=T, all.y = F)
### Figure out the settlement outcomes
defendant_outcomes_merged <- defendant_outcomes_merged %>% mutate(outcomePossession = case_when(outcomeCombined == "Dismissed" ~ "No decision: No judgment for possession",
outcomeCombined == "Withdrawn" ~ "No decision: No judgment for possession",
outcomeCombined == "Settled" ~ "No decision: No judgment for possession",
TRUE ~ "OTHER"))
defendant_outcomes_merged$details
### If default for plaintiff, is there possession
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Plaintiff by Default"] <- ifelse(grepl("possession", defendant_outcomes_merged$details[defendant_outcomes_merged$outcomeCombined == "For Plaintiff by Default"], ignore.case=T),
"Plaintiff wins: Judgment for possession", "Plaintiff wins: No judgment for possession")
### If decision for plaintiff, is there possession
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Plaintiff"]  <- ifelse(grepl("Judgment for possession", defendant_outcomes_merged$details[defendant_outcomes_merged$outcomeCombined == "For Plaintiff"], ignore.case=T),
"Plaintiff wins: Judgment for possession", "Plaintiff wins: No judgment for possession")
### If defendant wins - no possession
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Defendant"] <- "Defendant wins: No judgment for possession"
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Defendant by Default"] <- "Defendant wins: No judgment for possession"
### Figure out the settlement outcomes
defendant_outcomes_merged <- defendant_outcomes_merged %>% mutate(outcomePossession = case_when(outcomeCombined == "Dismissed" ~ "No decision: No judgment for possession",
outcomeCombined == "Withdrawn" ~ "No decision: No judgment for possession",
outcomeCombined == "Settled" ~ "No decision: No judgment for possession",
TRUE ~ "OTHER"))
defendant_outcomes_merged$details
### If default for plaintiff, is there possession
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Plaintiff by Default"] <- ifelse(grepl("possession", defendant_outcomes_merged$details[defendant_outcomes_merged$outcomeCombined == "For Plaintiff by Default"], ignore.case=T),
"Plaintiff wins: Judgment for possession", "Plaintiff wins: No judgment for possession")
### If decision for plaintiff, is there possession
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Plaintiff"]  <- ifelse(grepl("possession", defendant_outcomes_merged$details[defendant_outcomes_merged$outcomeCombined == "For Plaintiff"], ignore.case=T),
"Plaintiff wins: Judgment for possession", "Plaintiff wins: No judgment for possession")
### If defendant wins - no possession
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Defendant"] <- "Defendant wins: No judgment for possession"
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "For Defendant by Default"] <- "Defendant wins: No judgment for possession"
### If it's a judgment by agreement?
defendant_outcomes_merged$outcomePossession[defendant_outcomes_merged$outcomeCombined == "Judgment by Agreement"]  <- ifelse(grepl("possession", defendant_outcomes_merged$details[defendant_outcomes_merged$outcomeCombined == "Judgment by Agreement"], ignore.case=T),
"Agreement: Judgment for possession", "Agreement: No judgment for possession")
defendant_outcomes_merged$details[defendant_outcomes_merged$outcomePossession == "Plaintiff wins: No judgment for possession"]
defendant_outcomes_merged$details[defendant_outcomes_merged$outcomePossession == "Agreement: No judgment for possession"]
